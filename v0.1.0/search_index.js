var documenterSearchIndex = {"docs":
[{"location":"#NextStride","page":"Home","title":"NextStride","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FedericoStra/NextStride.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, the stride(A, k::Integer) function comes with three methods, which differ in behavior when k > ndims(A), specialized for arrays A of type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractArray: this version returns the value sum(strides(A) .* size(A));\nSubArray: this version returns the value strides(A)[end] * size(A)[end];\nUnion{DenseArray,Base.StridedReshapedArray,Base.StridedReinterpretArray}: this version returns the value length(A).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loading this package removes specializations (2)−(3) and leaves only the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> methods(stride)\n# 1 method for generic function \"stride\" from Base:\n [1] stride(A::AbstractArray{T, N}, k::Integer) where {T, N}\n     @ NextStride <source file>","category":"page"},{"location":"","page":"Home","title":"Home","text":"This new method is standardized in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"if k < 1, then it returns an error;\nif 1 ≤ k ≤ ndims(A), then it returns strides(A)[k];\nif k > ndims(A), then it returns the length (in elements, not bytes) of the shortest contiguous memory region accessed by A.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The integer returned in the third case is called next stride and can also be computed directly via the function next_stride(A).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, we have","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using NextStride\n\njulia> a = zeros(3,5,7);\n\njulia> p = PermutedDimsArray(a, (2,3,1));\n\njulia> v = view(p, :, 7:-2:1, 3:-1:1);\n\njulia> stride(a, 4), stride(p, 4), stride(v, 4)\n(105, 105, 105)","category":"page"},{"location":"","page":"Home","title":"Home","text":"whereas this code would return (105, 123, -3) without loading NextStride.","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#NextStride.next_stride","page":"Home","title":"NextStride.next_stride","text":"next_stride(A::AbstractArray) :: Integer\n\nReturn the length (in elements, not bytes) of the shortest contiguous memory region accessed by A.\n\nThis is the smallest positive stride which, if assigned to the first virtual axis beyond ndims(A), would prevent overlap between successive arrays of the same type of A.\n\nFor example, if ndims(A) == 2, we could have an array B with ndims(B) == 3 such that A == B[:,:,1]; next_stride(A) is the smallest positive stride(B, 3) that guarantees that B[:,:,1] and B[:,:,2] do not overlap in memory.\n\nExamples\n\njulia> a = zeros(3,5,7);\n\njulia> p = PermutedDimsArray(a, (2,3,1));\n\njulia> v = view(p, :, 7:-2:1, 3:-1:1);\n\njulia> next_stride(a), next_stride(p), next_stride(v)\n(105, 105, 105)\n\n\n\n\n\n","category":"function"}]
}
