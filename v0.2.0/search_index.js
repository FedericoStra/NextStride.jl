var documenterSearchIndex = {"docs":
[{"location":"#NextStride","page":"Home","title":"NextStride","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FedericoStra/NextStride.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis is an experimental project to work around the issue https://github.com/JuliaLang/julia/issues/58403.It redefines methods in the Base module and may not be safe for space travel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, the stride(A, k::Integer) function comes with three methods, which differ in behavior when k > ndims(A), specialized for arrays A of type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbstractArray: this version returns the value sum(strides(A) .* size(A));\nSubArray: this version returns the value strides(A)[end] * size(A)[end];\nUnion{DenseArray,Base.StridedReshapedArray,Base.StridedReinterpretArray}: this version returns the value length(A).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Loading this package removes specializations (2)−(3) and leaves only the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> methods(stride)\n# 1 method for generic function \"stride\" from Base:\n [1] stride(A::AbstractArray{T, N}, k::Integer) where {T, N}\n     @ NextStride <source file>","category":"page"},{"location":"","page":"Home","title":"Home","text":"This new method is standardized in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"if k < 1, then it returns an error;\nif 1 ≤ k ≤ ndims(A), then it returns strides(A)[k];\nif k > ndims(A), then it returns the length (in elements, not bytes) of the shortest contiguous memory region accessed by A.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The integer returned in the third case is called next stride and can also be computed directly via the function next_stride(A).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, we have","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using NextStride\n\njulia> a = zeros(3,5,7);\n\njulia> p = PermutedDimsArray(a, (2,3,1));\n\njulia> v = view(p, :, 7:-2:1, 3:-1:1);\n\njulia> stride(a, 4), stride(p, 4), stride(v, 4)\n(105, 105, 105)","category":"page"},{"location":"","page":"Home","title":"Home","text":"whereas this code would return (105, 123, -3) without loading NextStride.","category":"page"},{"location":"#Configuring-the-behavior","page":"Home","title":"Configuring the behavior","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The behavior of stride(A::AbstractArray, k::Integer) for k > ndims(A) can be configured by calling the function set_virtual_strides_behavior(B::VirtualStridesBehavior) with one of the following instances of the enumeration VirtualStridesBehavior:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ReturnError: returns an error;\nReturnZero: returns 0 (use with caution!);\nReturnNextStride: returns the \"next stride\" of A;\nCall_next_stride: calls next_stride(A).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that with option (3) the functions stride and next_stride remain independent of one another (and can therefore be specialized separately), whereas with option (4) they become coupled (adding methods to next_stride will affect the value returned by stride).","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nOptions (1) and especially (2) may break stuff!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Option (1) is always \"safe\" to use, because the worse it can do is throw an error if some code tries to call stride(A::AbstractArray, k::Integer) with k > ndims(A).","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, option (2) might not be safe because there is code in Julia's base libraries that accidentally relies on stride(A::AbstractArray, k::Integer) returning a non-zero value for k > ndims(A). One such example is LinearAlgebra.mul!(y, A, x) when called with a vector as second argument instead of a matrix. It treats it as a 1-column matrix and calls stride(A, 2) expecting a non-zero stride which is valid to pass to the underlying LinearAlgebra.BLAS.gemv! function (BLAS gemv functions explicitly require that lda must be positive). Setting the behavior of stride(A, 2) to return 0 instead may result in code that appears to be working, but it is definitely not correct.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using LinearAlgebra\n\njulia> mul!(zeros(3), [1., 2., 3.], [10.])\n3-element Vector{Float64}:\n 10.0\n 20.0\n 30.0\n\njulia> using NextStride\n\njulia> mul!(zeros(3), [1., 2., 3.], [10.]) # no problems here\n3-element Vector{Float64}:\n 10.0\n 20.0\n 30.0\n\njulia> NextStride.set_virtual_strides_behavior(NextStride.ReturnZero)\n\njulia> mul!(zeros(3), [1., 2., 3.], [10.]) # still *appears* to work correctly...\n3-element Vector{Float64}:\n 10.0\n 20.0\n 30.0\n\njulia> NextStride.set_virtual_strides_behavior(NextStride.ReturnError)\n\njulia> mul!(zeros(3), [1., 2., 3.], [10.])\nERROR: array strides: dimension out of range\nStacktrace:","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Public","page":"Home","title":"Public","text":"","category":"section"},{"location":"#Exported","page":"Home","title":"Exported","text":"","category":"section"},{"location":"#NextStride.next_stride","page":"Home","title":"NextStride.next_stride","text":"next_stride(A::AbstractArray) :: Integer\n\nReturn the length (in elements, not bytes) of the shortest contiguous memory region accessed by A.\n\nThis is the smallest positive stride which, if assigned to the first virtual axis beyond ndims(A), would prevent overlap between successive arrays of the same type of A.\n\nFor example, if ndims(A) == 2, we could have an array B with ndims(B) == 3 such that A == B[:,:,1]; next_stride(A) is the smallest positive stride(B, 3) that guarantees that B[:,:,1] and B[:,:,2] do not overlap in memory.\n\nExamples\n\njulia> a = zeros(3,5,7);\n\njulia> p = PermutedDimsArray(a, (2,3,1));\n\njulia> v = view(p, :, 7:-2:1, 3:-1:1);\n\njulia> next_stride(a), next_stride(p), next_stride(v)\n(105, 105, 105)\n\n\n\n\n\n","category":"function"},{"location":"#Non-exported","page":"Home","title":"Non exported","text":"","category":"section"},{"location":"#NextStride.VirtualStridesBehavior","page":"Home","title":"NextStride.VirtualStridesBehavior","text":"VirtualStridesBehavior <: Enum\n\nInstances\n\nReturnError\nReturnZero\nReturnNextStride\nCall_next_stride\n\nUsage\n\nInstances of this enumeration are passed to the function set_virtual_strides_behavior to configure the behavior of stride(A::AbstractArray, k::Integer) for k > ndims(A) according to this specification:\n\nReturnError: returns an error;\nReturnZero: returns 0 (use with caution!);\nReturnNextStride: returns the \"next stride\" of A;\nCall_next_stride: calls next_stride(A).\n\nNotice that with option (3) the functions stride and next_stride remain independent of one another (and can therefore be specialized separately), whereas with option (4) they become coupled (adding methods to next_stride will affect the value returned by stride).\n\n\n\n\n\n","category":"type"},{"location":"#NextStride.set_virtual_strides_behavior","page":"Home","title":"NextStride.set_virtual_strides_behavior","text":"set_virtual_strides_behavior(B::VirtualStridesBehavior)\n\nSet the behavior of stride(A::AbstractArray, k::Integer) for k > ndims(A) according to the specification B, which must be an instance of the enumeration VirtualStridesBehavior.\n\n\n\n\n\n","category":"function"},{"location":"#NextStride.virtual_strides_call_next_stride","page":"Home","title":"NextStride.virtual_strides_call_next_stride","text":"virtual_strides_call_next_stride()\n\nSet the behavior of stride(A::AbstractArray, k::Integer) to call next_stride(A) if k > ndims(A).\n\n\n\n\n\n","category":"function"},{"location":"#NextStride.virtual_strides_return_error","page":"Home","title":"NextStride.virtual_strides_return_error","text":"virtual_strides_return_error()\n\nSet the behavior of stride(A::AbstractArray, k::Integer) to return an error if k > ndims(A).\n\n\n\n\n\n","category":"function"},{"location":"#NextStride.virtual_strides_return_next_stride","page":"Home","title":"NextStride.virtual_strides_return_next_stride","text":"virtual_strides_return_next_stride()\n\nSet the behavior of stride(A::AbstractArray, k::Integer) to return the \"next stride\" if k > ndims(A).\n\n\n\n\n\n","category":"function"},{"location":"#NextStride.virtual_strides_return_zero","page":"Home","title":"NextStride.virtual_strides_return_zero","text":"virtual_strides_return_zero()\n\nSet the behavior of stride(A::AbstractArray, k::Integer) to return 0 if k > ndims(A).\n\n\n\n\n\n","category":"function"}]
}
